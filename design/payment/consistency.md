# Consistency

Гарантии целостности данных в платёжной системе.

## Денежные инварианты

### 1. Нельзя зарезервировать больше, чем доступно

**Что проверять:** `available = balance - reserved`. Если у пользователя 100₽ и 80₽ уже зарезервировано — доступно только 20₽, платёж на 50₽ не пройдёт.

**Риск:** Пользователь одновременно делает два платежа по 60₽ (с двух устройств). Оба запроса читают `available = 100`, оба видят "хватает", оба резервируют. Итог: зарезервировано 120₽ при балансе 100₽.

**Проблема:** Race condition на проверке. Обычная транзакция (READ COMMITTED) не спасает — она не блокирует строку при чтении. Обе транзакции читают `available = 100`, обе проверяют "хватает?", обе проходят проверку. Потом обе делают `UPDATE SET reserved = reserved + 60` — и оба UPDATE применяются.

SERIALIZABLE спас бы — PostgreSQL обнаружит конфликт и откатит одну транзакцию. Но SELECT FOR UPDATE лучше: вторая транзакция подождёт и выполнится с актуальными данными, а не упадёт с ошибкой.

**Защита:**

1. **SELECT FOR UPDATE.** Блокирует строку в момент чтения (не записи). Вторая транзакция ждёт на SELECT, а не на UPDATE. Когда первая завершится, вторая прочитает актуальные `balance` и `reserved`.

2. **CHECK constraints** — страховка на случай ошибки в коде. БД откатит транзакцию:
   - `CHECK (balance >= 0)` — баланс не отрицательный
   - `CHECK (reserved >= 0)` — резерв не отрицательный
   - `CHECK (reserved <= balance)` — нельзя зарезервировать больше, чем есть

### 2. Платёж проходит ровно один раз

**Риск:** Kafka доставил `PaymentCompleted` дважды (retry). Wallet делает commit дважды — списали 2x.

**Защита:** Резервация имеет статус. Переход возможен только один раз:

- Из `RESERVED` можно перейти в `COMMITTED` (успех) или `RELEASED` (отмена)
- Из `COMMITTED` или `RELEASED` переходов нет

Повторный commit видит статус `COMMITTED` и ничего не делает.

### 3. Провайдер — источник истины

**Риск:** Мы отправили запрос провайдеру, ждём callback. Callback не приходит — сеть, провайдер лежит, что угодно. Если мы решим "раз нет ответа — значит не прошло" и вернём деньги пользователю, а провайдер на самом деле списал — мы потеряли деньги.

**Правило:** Только провайдер знает, прошла транзакция или нет.

**Как защищаемся:**

При таймауте не считаем транзакцию неуспешной — проверяем Status API и ждём ответа. Timeout Reversal отправляем только если PENDING больше 7 дней.

Подробный flow: [Payment Flow — Timeout](payment-flow.md#timeout)
