# Identifiers

## Требования к paymentId

- Глобально уникален
- Сортируем по времени
- Не требует централизованного генератора в БД

## Решение: UUIDv7

UUIDv7 содержит timestamp в первых 48 битах — сортируем по времени и глобально уникален.
Генерируется на любом сервисе без координации.

## Использование

| Система | Применение |
|---------|------------|
| Payments DB | PRIMARY KEY, генерируется в сервисе или PostgreSQL 18 (uuidv7()) |
| Wallet | Связь reserve/commit с платежом через payment_id (поле text) |
| Kafka | Ключ партицирования — события одного платежа в одной партиции |
| Логи/трейсинг | payment_id для поиска записей по платежу, trace_id для анализа пути запроса |
| Callbacks мерчантам | Мерчант получает UUID для дебага |

## Влияние на производительность

- Локальность вставок OK (как у sequence) — в первых 48 битах timestamp
- Размер ключа: 16 byte vs 8 byte (sequence)
- Рост индекса в ~2 раза быстрее

## Миграция

- Старые ID сохраняем, делаем маппинг sequence -> UUIDv7
- Текущие внешние API: видят оба ID или обращаются к API v2
- Будущие внешние API: только UUIDv7
- Существующие платежи: не трогаем, не генерируем новые ID
- Каждый микросервис: логика резолва ID по типу (число или текст)
- Двоичная совместимость не нужна — старые ID только внутри legacy и ACL-маппинге
